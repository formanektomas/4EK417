library(sf)
library(RCzechia)
library(terra) 
library(dplyr)
library(exactextractr)
library(ggplot2)
rm(list = ls())
#
#
#-----------------
#
# Example 1: Raster data manipulation
# - visualize raster data
# - crop and mask 
# - move raster data into {sf} objects - administrative regions, hexagonal grid, etc.
# - combine adjacent (and maybe partially overlapping) rasters using {terra:mosaic()}
#
#-----------------
#
# get raster data (Copenicus-based, approx. 70 MB)
CZProfile <- RCzechia::vyskopis(format="actual",cropped = F)
CZProfile
# get Czechia state boundaries
CZbound <- RCzechia::republika(resolution = "low")
#
# plot raster
plot(CZProfile)
plot(CZbound,
     border = "red",
     col = NA,
     add = TRUE)
#
# crop raster image (to a bounding box of CZ borders)
cropped <- terra::crop(CZProfile, CZbound) # crop raster to the bbox of polygon
#
# plot cropped raster
plot(cropped)
plot(CZbound,
     border = "red",
     col = NA,
     add = TRUE)
#
# mask to a defined polygon boundary (drop rest)
masked <- terra::mask(cropped, CZbound)
#
# plot masked raster
plot(masked)
#
# Note: masking can be done without cropping, yet cropping adjusts map "range"
# to match the object of interest
# Compare to:
CZProfile %>% 
  terra::mask(CZbound) %>% 
  plot()
#
#-----------------
#
# Move raster-format data into sf objects
#
# a) calculate average profile (meters) of counties
CZcounties <- RCzechia::okresy(resolution = "low")
#
# CZcounties is an {sf} object, create a new variable with profile height value (m)
CZcounties$meters <- exactextractr::exact_extract(
  x = masked, # source, masked raster with CZ profile
  y = CZcounties, # target, sf polygons 
  fun = "mean", # calculation of average profile height 
  weights = "area",
  coverage_area = T
) 
#
# plot processed data
ggplot(data = CZcounties, aes(fill = meters, label = round(meters))) +
  geom_sf(lwd = 1/3) +
  # scale_fill_viridis_c(name = "Terrain \nprofile",option = "H") +
  scale_fill_gradient(low = 'springgreen1', high = 'tan4')+
  theme(axis.title = element_blank(),
        plot.caption = element_text(face = "italic"))
#
#
# b) calculate average profile on hexagonal grid
grid1 <- st_make_grid(CZbound, square = F, n = c(60,30)) # n=c(columns, rows)
plot(grid1)
CZgrid <- st_intersection(grid1,CZbound)
plot(CZgrid)
CZgrid <- st_as_sf(CZgrid)
# the grid needs some "work", format adjusting and data cleaning:
# 1) only polygons and multipolygons are allowed in exact_extract()
#    (lines and poins can be generated by the intersection() function)
# 2) the geometry column needs to be named "geometry" (it's named x now)
# 3) we may want to have ID for each hexagon, for additional processing
#
CZgrid <- CZgrid[st_is(CZgrid,c("POLYGON", "MULTIPOLYGON")),] # filter (multi)polygons
CZgrid$PolID <- 1:nrow(CZgrid) # row numbering
CZgrid 
st_geometry(CZgrid) <- "geometry"
CZgrid
#
# Calculate average profile and plot the data
CZgrid$meters <- exactextractr::exact_extract(
  x = masked, # source, masked raster with CZ profile
  y = CZgrid, # target, sf polygons 
  fun = "mean", # calculation of average built-up - can be used for air pollution, etc.
  weights = "area",
  coverage_area = T
) 
#
# plot processed data
ggplot(data = CZgrid, aes(fill = meters, label = round(meters))) +
  geom_sf(lwd = 1/3) +
  # scale_fill_viridis_c(name = "Terrain \nprofile",option = "H") +
  scale_fill_gradient(low = 'springgreen1', high = 'tan4')+
  theme(axis.title = element_blank(),
        plot.caption = element_text(face = "italic"))
#  
#
# Why move precise raster data to aggregated {sf} objects?
# - spatial dependency analysis, regression models (relate profile to population density, etc.)
# - sf format is compatible with most statistical methods...
#
#
#-----------------
#
# Combine adjacent (and maybe partially overlapping) rasters using {terra:mosaic()}
# - say, we download satellite photographs for analysis, yet wee need to combine
#   them into one file for subsequent analysis:
#
# terra help-based example:
?terra::mosaic
x <- rast(xmin=-110, xmax=-60, ymin=40, ymax=70, res=1, vals=1)
y <- rast(xmin=-95, xmax=-45, ymax=60, ymin=30, res=1, vals=2)
z <- rast(xmin=-80, xmax=-30, ymax=50, ymin=20, res=1, vals=3)
# 
# x,y,z are 3 different rasters, partly overlapping, "observed" values are
# also different (1,2,3)
m1 <- mosaic(x, y, z, fun="mean") # fun="mean" is the default setting
#
plot(x)
plot(y)
plot(z)
plot(m1) # note how values in overlapping areas are averaged
#
#
#---------------------------------------------------------  
#
# Self-study example 1: built-up area analysis for Czechia.
#
# (for self-study due to the size of images that need to be downloaded)
#
# Step 1 
# Download a pre-processed image from Copernicus
#
# https://human-settlement.emergency.copernicus.eu/download.php
#
# https://jeodpp.jrc.ec.europa.eu/ftp/jrc-opendata/GHSL/GHS_BUILT_S_GLOBE_R2023A/GHS_BUILT_S_E2020_GLOBE_R2023A_54009_100/V1-0/tiles/GHS_BUILT_S_E2020_GLOBE_R2023A_54009_100_V1_0_R4_C19.zip
# https://jeodpp.jrc.ec.europa.eu/ftp/jrc-opendata/GHSL/GHS_BUILT_S_GLOBE_R2023A/GHS_BUILT_S_E2020_GLOBE_R2023A_54009_100/V1-0/tiles/GHS_BUILT_S_E2020_GLOBE_R2023A_54009_100_V1_0_R4_C20.zip
#
# Save the first file as "CE_north.tif", save second file as "CE_south.tif"
# GHS_BUILT_S_E2020_GLOBE_R2023A_54009_100_V1_0_R4_C20
#
#----------------
CE_east <- terra::rast("GHS_BUILT_S_E2020_GLOBE_R2023A_54009_100_V1_0_R4_C20.tif")
CE_west <- terra::rast("GHS_BUILT_S_E2020_GLOBE_R2023A_54009_100_V1_0_R4_C19.tif")
CE <- mosaic(CE_east, CE_west, fun="mean")
CE # EPSG 6326,
# 
plot(CE)
#----------------
# for simpler calculation (100x100 meter grid), transform CZbound and CZcounties
# to Mollweide 
plot(CZbound)
CZbound <- st_transform(CZbound, crs = "ESRI:54009")
plot(CZbound)
CZcounties <- st_transform(CZcounties, crs = "ESRI:54009")
#
# 
#
cropped <- terra::crop(CE, CZbound) # crop
CZrast <- terra::mask(cropped, CZbound) # mask to a defined polygon boundary
terra::plot(CZrast, main = "Built-up raster data")
plot(CZcounties$geometry, add = T, border=0)
#-----------------
#
# calculate average buitup area (proportion) at county level
# can be done similarly for LAU-units, NUTS regions, etc.
#
CZcounties$builtup <- exactextractr::exact_extract(
  x = CE, # source
  y = CZcounties, # target
  fun = "mean", # calculation of average built-up 
  weights = "area",
  coverage_area = T
) 
#
# built-up is in m2 in a given 10.000 m2 element.
CZcounties$builtup <- CZcounties$builtup/100 # on a scale 0-100
#-----------------
#
ggplot(data = CZcounties, aes(fill = builtup, label = round(builtup))) +
  geom_sf(lwd = 1/3) +
  scale_fill_viridis_c(name = "Build-up area\n(as % of total)\n ") +
  labs(title = "Build-up relative area as of 2020",
       caption = " (c) Copernicus Service Information 2019") +
  theme(axis.title = element_blank(),
        plot.caption = element_text(face = "italic"))
#
#-----------------
#
# save data with spatial information preserved
st_write(counties,"CZcounties.gpkg")
#
savedDF <- st_read("CZcounties.gpkg")
savedDF # compare to using write.csv() or similar functions
#
#
#
# The number of hexagons (80x100 is ad-hoc)
# you need to evaluate and change for each region you work with
grid1 <- st_make_grid(CZbound, square = F, n = c(80,100)) # n=c(columns, rows)
plot(grid1)
CZgrid <- st_intersection(grid1,CZbound)
plot(CZgrid)
CZgrid <- st_as_sf(CZgrid)
# data cleaning (necesary for exactextract to work)
# choose polygons and multipolygons only, drop the rest (lines, points, etc.).
CZgrid <- CZgrid[st_is(CZgrid,c("POLYGON", "MULTIPOLYGON")),] 
CZgrid$PolID <- 1:nrow(CZgrid)
CZgrid
st_geometry(CZgrid) <- "geometry"
CZgrid
plot(CZgrid)
# can be used for exactextract - calculate values from satellite image to each hexagon
#
#
CZgrid$builtup <- exactextractr::exact_extract(
  x = CE, # source
  y = CZgrid, # target
  fun = "mean", # calculation of average built-up - can be used for air pollution, etc.
  weights = "area",
  coverage_area = T
) 
CZgrid$builtup <- CZgrid$builtup/100
CZgrid <- st_transform(CZgrid, crs = "EPSG:4326")
CZcounties <- st_transform(CZcounties, crs = "EPSG:4326")
#
#-----------------
#
ggplot(data = CZgrid, aes(fill = builtup, label = round(builtup))) +
  geom_sf(lwd = 1/3) +
  scale_fill_viridis_c(name = "Build-up area\n(as % of total)\n ") +
  labs(title = "Build-up relative area as of 2020",
       caption = " (c) Copernicus Service Information 2019") +
  geom_sf(data=CZcounties, fill=NA, color = "white") +
  theme(axis.title = element_blank(),
        plot.caption = element_text(face = "italic"))
#
#
st_write(CZgrid, "EUpolygons.gpkg",delete_dsn = T) 
#
#
#
#---------------------------------------------------------  
#
# Self-study example 3: NO2 pollution in Europe
#
#---------------------------------------------------------  
#
library(ncdf4) # package for netcdf manipulation
rm(list = ls())
#
# website: https://maps.s5p-pal.com/no2/
# download NO2 pollution image data using the icon on lower-right of the map
# change name of the NetCDF to some simple name, eg. "NO2data.nc"
# Note: File has approx. 1GB
#
# example follows from the tutorial here: https://rpubs.com/boyerag/297592
# and https://rpubs.com/GeospatialEcologist/SpatialRaster
#
#-----------------
#
r <- terra::rast("NO2data.nc")
r
plot(r)
plot(r[[1]])
# The maps show the concentration of nitrogen dioxide (NO2) in the lowest kilometers 
# of the atmosphere. Nitrogen oxides are mainly produced by human activity and the 
# combustion of (fossil) fuels, such as road traffic, ships, power plants and other 
# industrial facilities. Burning activities and wildfires also contribute significantly 
# to the NO2 concentrations observed. NO2 can have a significant impact on human health, 
# both directly and indirectly through the formation of ozone and small particles.


# crop to Europe
EuropeBBOX <- sf::st_bbox(c(xmin = -9, xmax = 32, ymax = 72, ymin = 35), crs = sf::st_crs(4326))
rEurope <- crop(r[[1]], EuropeBBOX)
plot(rEurope)
#
writeCDF(rEurope, "NO2Europe.nc", overwrite=TRUE, varname="NO2",
         longname="troposhperic_NO2_density_umol/m2")
#
# 
library(giscoR)
NUTS3 <- giscoR::gisco_get_nuts(country=c("Germany","Austria","Czechia"),nuts_level = 3)
NUTS0 <- giscoR::gisco_get_nuts(country=c("Germany","Austria","Czechia"),nuts_level = 0)
NUTS0 <- select(NUTS0, NUTS_ID)

NUTS3$NO2 <- exactextractr::exact_extract(
  x = rEurope, # source
  y = NUTS3, # target
  fun = "mean", # calculation of average air pollution in the area
  weights = "area"
) 
# 
summary(NUTS3$NO2)
# Plot the results
ggplot(data = NUTS3) +
  geom_sf(aes(fill = NO2), lwd = 1/3) +
  scale_fill_viridis_c(name = "NO2 air\npollution") +
  labs(title = "NO2 air pollution infomap",
       caption = " (c) Copernicus Service Information") +
  geom_sf(data=NUTS0, color="white", fill=NA, linewidth=1)+
  theme_dark()
#
# Note:
# as.data.frame(raster_object, na.rm = TRUE)
# .. works as well, 
# .. can be used for rastered datasets (multi-layered) that have
# .. same spatial extent, the same resolution, and are aligned 
# .. However, the above shown approach tends to be more general and useful.